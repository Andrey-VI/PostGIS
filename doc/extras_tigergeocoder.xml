<?xml version="1.0" encoding="UTF-8"?>

  <sect1 id="Tiger_Geocoder">
	<title>Tiger Geocoder</title>
	 <sect1info>
		<abstract>
			<para>A plpgsql based geocoder written for <ulink url="http://www.census.gov/geo/www/tiger/index.html">TIGER census data</ulink>.</para>
			<para>There are three components to the geocoder: the data loader functions, the address normalizer and the address geocoder. The lastest version updated to use the TIGER 2010 census data is located in the extras/tiger_geocoder/tiger_2010 folder.</para>
			<para>The script builds a schema called <varname>tiger</varname>: to house all the tiger related functions, reusable lookup data such as road type prefixes, suffixes, states, and skeleton base tables from which all the tiger loaded tables inherit from.</para>
			<para>Another schema called <varname>tiger_data</varname> is also created which houses all the census data for each state that the loader downloads from Census site and loads into the database. In the current model, each set of state tables is
			    prefixed with the state code e.g ma_addr, ca_edges etc with constraints to enforce only that state data.  Each of these tables inherits from the base addr, faces, egdes, etc located in the tiger schema. </para>
			<para>All the geocode functions only reference the base tables, so there is no requirement that the data schema be called <varname>tiger_data</varname> or that data can't be further partitioned into other schemas -- e.g a different schema
			for each state, as long as all the tables inherit from the tables in the <varname>tiger</varname> schema.</para>
			<para>Design:</para>
			<para>The goal of this project is to build a fully functional geocoder that can process an arbitrary 
			address string and, using normalized TIGER census data, produce a point geometry and rating reflecting the location of the given address.</para>
			<para>The geocoder should be simple for anyone familiar with PostGIS to install and use, and should be easily installable and usable on all platforms supported by PostGIS.</para>
			<para>It should be robust enough to function properly despite formatting and spelling errors.</para>
			<para>It should be extensible enough to be used with future data updates, or alternate data sources with a minimum of coding changes.</para>
		</abstract>
     </sect1info>
	
	<refentry id="Geocode">
	  <refnamediv>
		<refname>Geocode</refname>

		<refpurpose>Takes in an address as a string (or other normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a normalized address for each, and the rating.  The lower the rating the more likely the match.  
			Results are sorted by lowest rating first.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>setof record <function>geocode</function></funcdef>
			<paramdef><type>address </type> <parameter>varchar</parameter></paramdef>
			<paramdef><type>OUT addy </type> <parameter>norm_addy</parameter></paramdef>
			<paramdef><type>OUT geomout </type> <parameter>geometry</parameter></paramdef>
			<paramdef><type>OUT rating </type> <parameter>integer</parameter></paramdef>
		  </funcprototype>
		  <funcprototype>
			<funcdef>setof record <function>geocode</function></funcdef>
			<paramdef><type>in_addy </type> <parameter>norm_addy</parameter></paramdef>
			<paramdef><type>OUT addy </type> <parameter>norm_addy</parameter></paramdef>
			<paramdef><type>OUT geomout </type> <parameter>geometry</parameter></paramdef>
			<paramdef><type>OUT rating </type> <parameter>integer</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Takes in an address as a string (or already normalized address) and outputs a set of possible locations which include a point geometry in NAD 83 long lat, a <varname>normalized_address</varname> (addy) for each, and the rating.  The lower the rating the more likely the match.  
			Results are sorted by lowest rating first.  Uses Tiger data (edges,faces,addr), PostgreSQL fuzzy string matching (soundex,levenshtein) and PostGIS line interpolation functions to interpolate address along the Tiger edges. The higher the rating the less likely the geocode is right.</para>

		<para>Enhanced: 2.0.0 to support Tiger 2010 structured data and revised some logic to improve speed.</para>


	  </refsection>


	  <refsection>
		<title>Examples</title>
		<para>The below examples timings are on a fairly old 1.9 GHZ single processor Windows XP machine with 3GB ram running PostgreSQL 9/PostGIS 2.0 loaded with all of Massachusetts state Tiger data.</para>
		<para>Exact matches are faster to compute (205ms)</para>
		<programlisting>SELECT g.rating, ST_X(g.geomout) As lon, ST_Y(g.geomout) As lat, 
	(addy).address As stno, (addy).streetname As street, 
	(addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
	FROM geocode('75 State Street, Boston MA 02109') As g;  
 rating |        lon        |       lat        | stno | street | styp |  city   |st  |  zip
 --------+-------------------+------------------+------+--------+------+--------+----+-------
      0 | -71.0556974285714 | 42.3590795714286 |   75 | State  | St   | Boston  | MA | 02109
</programlisting>
		<para>Even if zip is not passed in the geocoder can guess (took about 450 ms)</para>
		<programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat, 
	(addy).address As stno, (addy).streetname As street, 
	(addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
	FROM geocode('226 Hanover Street, Boston, MA') As g;  
 rating |         wktlonlat         | stno | street  | styp |  city  | st |  zip
--------+---------------------------+------+---------+------+--------+----+-------
      0 | POINT(-71.05518 42.36311) |  226 | Hanover | St   | Boston | MA | 02113
</programlisting>     
<para>Can handle misspellings and provides more than one possible solution with ratings and takes longer (4 seconds).</para>
<programlisting>SELECT g.rating, ST_AsText(ST_SnapToGrid(g.geomout,0.00001)) As wktlonlat, 
    (addy).address As stno, (addy).streetname As street, 
	(addy).streettypeabbrev As styp, (addy).location As city, (addy).stateabbrev As st,(addy).zip 
	FROM geocode('31 - 37 Stewart Street, Boston, MA 02116') As g; 
 rating |         wktlonlat         | stno | street  | styp |     city      | st|  zip
--------+---------------------------+------+---------+------+---------------+----+-------
     55 | POINT(-71.36934 42.68158) |   31 | Stewart | St   | Lowell        | MA | 01826
     55 | POINT(-71.34825 42.63324) |   31 | Stewart | St   | Lowell        | MA | 01851
     55 | POINT(-71.59109 42.22556) |   31 | Stewart | St   | Hopkinton     | MA | 01748
     56 | POINT(-71.26747 42.54075) |   31 | Stewart | St   | Burlington    | MA | 01821
     56 | POINT(-71.20324 42.53543) |   31 | Stewart | St   | Burlington    | MA | 01803
     57 | POINT(-72.57319 42.22111) |   31 | Stewart | St   | Chicopee      | MA | 01075
     57 | POINT(-72.59728 42.16919) |   31 | Stewart | St   | Chicopee      | MA | 01020
     59 | POINT(-71.08627 42.78109) |   31 | Stewart | St   | Haverhill     | MA | 01830
     60 | POINT(-71.36752 42.09772) |   31 | Stewart | St   | Franklin Town | MA | 02038
     60 | POINT(-71.14573 41.72036) |   31 | Stewart | St   | Fall River    | MA | 02720
     70 | POINT(-71.0646 42.35105)  |   31 | Stuart  | St   | Boston        | MA | 02116
(11 rows)	</programlisting>

<para>Using to do a batch geocode of addresses.  Note you can get a similar output if you use <xref linkend="Pprint_Addy" /> to glue the parts together.  E.g <varname>pprint_addy((g.addy))</varname></para>
<programlisting>CREATE TABLE addresses_to_geocode(addid serial PRIMARY KEY, address text,
		lon numeric, lat numeric, new_address text, rating integer);

INSERT INTO addresses_to_geocode(address)
VALUES ('529 Main Street, Boston MA, 02129'),
 ('77 Massachusetts Avenue, Cambridge, MA 02139'),
 ('28 Capen Street, Medford, MA'),
 ('124 Mount Auburn St, Cambridge, Massachusetts 02138'),
 ('950 Main Street, Worcester, MA 01610');
 
-- only update the first two addresses --
-- for large numbers of addresses you don't want to update all at once
-- since the whole geocode must commit at once (828 ms)
UPDATE addresses_to_geocode
  SET  (rating, new_address, lon, lat) 
	= (g.rating, COALESCE( (g.addy).address::text, '')
	|| COALESCE(' ' || trim((g.addy).predirabbrev ) , '') 
	|| COALESCE(' ' || trim((g.addy).streetname ),'') 
        || COALESCE(' ' || trim((g.addy).streettypeabbrev ), '') 
	|| COALESCE(' ' || (g.addy).location , '')
	|| COALESCE(', ' || (g.addy).stateabbrev, '') 
    || COALESCE(' ' || (g.addy).zip, ''),
		ST_X(g.geomout)::numeric(8,5), ST_Y(g.geomout)::numeric(8,5) )
FROM (SELECT DISTINCT ON (addid) addid, (g1.geo).*
	FROM (SELECT addid,  (geocode(address)) As geo
FROM addresses_to_geocode As ag
	WHERE ag.rating IS NULL ) As g1
ORDER BY addid, rating LIMIT 2) As g
WHERE g.addid = addresses_to_geocode.addid;

result
-----
2 rows affected, 850 ms execution time.

SELECT * FROM addresses_to_geocode WHERE rating is not null;

 addid |                   address                    |    lon    |   lat    |             new_address                  | rating
-------+----------------------------------------------+-----------+----------+------------------------------------------+--------
     1 | 529 Main Street, Boston MA, 02129            | -71.07187 | 42.38351 | 529 Main St Boston, MA 02129             |      0
     2 | 77 Massachusetts Avenue, Cambridge, MA 02139 | -71.09436 | 42.35981 | 77 Massachusetts Ave Cambridge, MA 02139 |      0</programlisting>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="Normalize_Address" />,<xref linkend="Pprint_Addy" />,<xref linkend="ST_AsText"/>,<xref linkend="ST_SnapToGrid"/>, <xref linkend="ST_X"/>, <xref linkend="ST_Y"/></para>
	  </refsection>
	</refentry>
	
	<refentry id="Normalize_Address">
	  <refnamediv>
		<refname>Normalize_Address</refname>

		<refpurpose>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>norm_addy <function>normalize_address</function></funcdef>
			<paramdef><type>address </type> <parameter>varchar</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>Given a textual street address, returns a composite <varname>norm_addy</varname> type that has road suffix, prefix and type standardized, street, streetname etc. broken into separate fields.  This is the first step in the geocoding process to 
		    get all addresses into normalized postal form. No other data is required aside from what is packaged with the geocoder.</para>
		<para>Fields in the <varname>norm_addy</varname> type object returned by this function in this order where  () indicates a field required by the geocoder, [] indicates an optional field:</para>
		<para>(address) [dirPrefix] (streetName) [streetType] [dirSuffix][internal] [location] [state] [zipCode]</para>
         <orderedlist>
          <listitem>
            <para><varname>address</varname> is an integer:  The street number</para>
          </listitem>
          <listitem>
            <para><varname>dirPrefix</varname> is varchar: Directional prefix of road such as N, S, E, W etc.  These are controlled using the <varname>direction_lookup</varname> table.</para>
          </listitem>
          <listitem>
            <para><varname>streetName</varname> varchar</para>
          </listitem>
          <listitem>
            <para><varname>streetType</varname> varchar abbreviated version of street type: e.g. St, Ave, Cir.  These are controlled using the <varname>street_type_lookup</varname> table.</para>
          </listitem>
          <listitem>
            <para><varname>dirSuffix</varname> varchar abbreviated version of street suffix. These are controlled using the <varname>direction_lookup</varname> table.</para>
          </listitem>
          <listitem>
            <para><varname>internal</varname> varchar internal address such as an apartment or suite number.</para>
          </listitem>
          <listitem>
            <para><varname>location</varname> varchar usually a city or governing province.</para>
          </listitem>
           <listitem>
            <para><varname>state</varname> varchar two character US State.  e.g MA, NY, MI</para>
          </listitem>
          <listitem>
            <para><varname>zip</varname> varchar 5-digit zipcode. e.g. 02109.</para>
          </listitem>
        </orderedlist>

	  </refsection>


	  <refsection>
		<title>Examples</title>
		<para>Output select fields.  Use <xref linkend="Pprint_Addy" /> if you want a pretty textual output.</para>
		<programlisting>SELECT address As orig, (g.na).streetname, (g.na).streettypeabbrev
 FROM (SELECT address, normalize_address(address) As na
        FROM addresses_to_geocode) As g;
        
                        orig                         |  streetname   | streettypeabbrev
-----------------------------------------------------+---------------+------------------
 529 Main Street, Boston MA, 02129                   | Main          | St
 77 Massachusetts Avenue, Cambridge, MA 02139        | Massachusetts | Ave
 28 Capen Street, Medford, MA                        | Capen         | St
 124 Mount Auburn St, Cambridge, Massachusetts 02138 | Mount Auburn  | St
 950 Main Street, Worcester, MA 01610                | Main          | St
		</programlisting>
		
		

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="Geocode"/>, <xref linkend="Pprint_Addy"/></para>
	  </refsection>
	</refentry>
	
	<refentry id="Pprint_Addy">
	  <refnamediv>
		<refname>Pprint_Addy</refname>

		<refpurpose>Given a <varname>norm_addy</varname> composite type object, returns a pretty print representation of it. Usually used in conjunction with normalize_address.</refpurpose>
	  </refnamediv>

	  <refsynopsisdiv>
		<funcsynopsis>
		  <funcprototype>
			<funcdef>varchar <function>pprint_addy</function></funcdef>
			<paramdef><type>address </type> <parameter>varchar</parameter></paramdef>
		  </funcprototype>
		</funcsynopsis>
	  </refsynopsisdiv>

	  <refsection>
		<title>Description</title>

		<para>>Given a <varname>norm_addy</varname> composite type object, returns a pretty print representation of it. No other data is required aside from what is packaged with the geocoder.</para>
		<para>Usually used in conjunction with <xref linkend="Normalize_Address"/>.</para>
		

	  </refsection>


	  <refsection>
		<title>Examples</title>
		<para>Pretty print a single address</para>
		<programlisting>SELECT pprint_addy(normalize_address('202 East Fremont Street, Las Vegas, Nevada 89101')) As pretty_address;
            pretty_address
---------------------------------------
 202 E Fremont St, Las Vegas, NV 89101
		</programlisting>
		
		<para>Pretty print address a table of addresses</para>
		<programlisting>SELECT address As orig, pprint_addy(normalize_address(address)) As pretty_address;
        FROM addresses_to_geocode;
        
                        orig                         |              pretty_address
-----------------------------------------------------+-------------------------------------------
 529 Main Street, Boston MA, 02129                   | 529 Main St, Boston MA, 02129
 77 Massachusetts Avenue, Cambridge, MA 02139        | 77 Massachusetts Ave, Cambridge, MA 02139
 28 Capen Street, Medford, MA                        | 28 Capen St, Medford, MA
 124 Mount Auburn St, Cambridge, Massachusetts 02138 | 124 Mount Auburn St, Cambridge, MA 02138
 950 Main Street, Worcester, MA 01610                | 950 Main St, Worcester, MA 01610</programlisting>

	  </refsection>

	  <!-- Optionally add a "See Also" section -->
	  <refsection>
		<title>See Also</title>
		<para><xref linkend="Normalize_Address"/></para>
	  </refsection>
	</refentry>

  </sect1>
