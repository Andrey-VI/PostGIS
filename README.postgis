PostGIS - Geographic Information Systems Extensions to PostgreSQL
~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

VERSION: 0.7 (2002/05/04)

MORE INFORMATION: http://postgis.refractions.net

INTRODUCTION:
This distribution contains a module which implements GIS simple 
features, ties the features to rtree indexing, and provides some 
spatial functions for accessing and analyzing geographic data.

Directory structure:

  ./      Core source code, makefiles and install directions.
  ./jdbc  Extensions to the PostgreSQL JDBC drivers to support
          the GIS objects. 
  ./doc   Documentation on the code, objects and functions 
          provided. 
  ./loader  A program to convert ESRI Shape files into SQL text
          suitable for uploading into a PostGIS/PostgreSQL database.
  ./examples  Small programs which demonstrate ways of accessing 
          GIS data.
	        

INSTALLATION:

To install the module, move this directory to the "contrib" directory of your
PostgreSQL source installation. Alternately, edit the "top_buildir" in the 
Makefile and point it at your PostgreSQL source tree. You must have a 
PostgreSQL source tree, and you must have run succesfully built and installed
it for this to work.

* POSTGRESQL 7.2 SUPPORT: 
  PostgreSQL 7.1 and 7.2 spatial indexes are *not* compatible. You must
  compile for one version or the other. To use PostgreSQL 7.2,
  edit the postgis Makefile and change the USE_PG72 variable to 1.

* PROJ4 SUPPORT: 
  The Proj4 reproject library is require if you want to use the 
  transform() function to reproject features within the database.
  Install Proj4 in the default location.
  Edit the postgis Makefile and change the USE_PROJ variable to 1.

As root run:
	
  make
  make install

PostGIS now requires the PL/pgSQL procedural language in order to operate
correctly. To install PL/pgSQL use the 'createlang' program from the PostgreSQL
installation. (The PostgreSQL Programmer's Guide has details if you want 
to this manually for some reason.)

As postgres run:

  createlang plpgsql yourdatabase
  psql -f postgis.sql -d yourdatabase

Installation should now be complete.


UPGRADING:

Upgrading PostGIS can be tricky, because the underlying C libraries which 
support the object types and geometries may have changed between versions.
To avoid problems when upgrading, you will have to dump all the tables
in your database, destroy the database, create a new one, add the PL/pgSQL
language, upload the new postgis.sql file, then upload your database dump:

  pg_dump -t "*" -f dumpfile.sql yourdatabase
  dropdb yourdatabase
  createdb yourdatabase
  createlang plpgsql yourdatabase
  psql -f postgis.sql -d yourdatabase
  psql -f dumpfile.sql -d yourdatabase
  vacuumdb -z yourdatabase

When upgrading to 0.6+, all your geometries will be created with an SRID
of -1. To create valid OpenGIS geometries, you will have to create a 
valid SRID in the SPATIAL_REF_SYS table, and then update your geometries
to reference the SRID with the following SQL (with the appropriate
substitutions:

  UPDATE <table> SET <geocolumn> = SetSRID(<geocolumn>,<SRID>);


USAGE:

Try the following example SQL statements to create non-OpenGIS tables and 
geometries:

  CREATE TABLE geom_test ( gid int4, geom geometry,name varchar(25) );
  INSERT INTO geom_test ( gid, geom, name ) 
    VALUES ( 1, 'POLYGON((0 0 0,0 5 0,5 5 0,5 0 0,0 0 0))', '3D Square');
  INSERT INTO geom_test ( gid, geom, name ) 
    VALUES ( 2, 'LINESTRING(1 1 1,5 5 5,7 7 5)', '3D Line' );
  INSERT INTO geom_test ( gid, geom, name )
    VALUES ( 3, 'MULTIPOINT(3 4,8 9)', '2D Aggregate Point' );
  SELECT * from geom_test WHERE geom && 'BOX3D(2 2 0,3 3 0)'::box3d;

The following SQL creates proper OpenGIS entries in the SPATIAL_REF_SYS
and GEOMETRY_COLUMNS tables, and ensures that all geometries are created
with an SRID.

  INSERT INTO SPATIAL_REF_SYS
    ( SRID, AUTH_NAME, AUTH_SRID, SRTEXT ) VALUES
    ( 1, 'EPSG', 4269,
      'GEOGCS["NAD83",
        DATUM[
          "North_American_Datum_1983",
          SPHEROID[
          "GRS 1980",
          6378137,
          298.257222101
        ]
      ],
      PRIMEM["Greenwich",0],
      UNIT["degree",0.0174532925199433]]'
    );

  CREATE TABLE geotest (
    id INT4,
    name VARCHAR(32)
    );

  SELECT AddGeometryColumn('db','geotest','geopoint',1,'POINT',2);

  INSERT INTO geotest (id, name, geopoint)
    VALUES (1, 'Olympia', GeometryFromText('POINT(-122.90 46.97)',1));
  INSERT INTO geotest (id, name, geopoint)
    VALUES (2, 'Renton', GeometryFromText('POINT(-122.22 47.50)',1));

  SELECT name,AsText(geopoint) FROM geotest;


Spatial Indexes:

PostgreSQL provides support for GiST spatial indexing. The GiST scheme offers 
indexing even on large objects, using a system of "lossy" indexing where 
a large object is proxied by a smaller one in the index.  In the case 
of the PostGIS indexing system, all objects are proxied in the index by 
their bounding boxes.

You can build a GiST index with:

  CREATE INDEX <indexname> ON <tablename>  
     USING gist ( <geometryfield> gist_geometry_ops ) WITH ( islossy );

Always run the "VACUUM ANALYZE <tablename>" on your tables after
creating an index. This gathers statistics which the query planner
uses to optimize index usage.

Note that PostgreSQL may occasionally not use the GiST indexes when 
performing searches. If you find your system is not using the 
indexes automatically (use 'EXPLAIN' to see the query plan)
you can force index use with the command: 

  SET ENABLE_SEQSCAN = OFF

Try doing an EXPLAIN on your query before and after the 'enable_seqscan'
command to see the different query plans.

